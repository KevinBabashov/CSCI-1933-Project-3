Method                  ArrayList Runtime           LinkedListRuntime       Explanation
boolean add(T element)      O(1)                           O(n)             For arrayList we use System.arraycopy which can range anywhere between O(1) and O(n) depending on the amount of elements, however here we decided on O(1) because arraycopy is dependent on the amount of elements, and elements in this case can range but no to suffice O(n). For LinkedList Runtime we have decided O(n) due in fact that if we want to add an element to the linked list majority of the time we have to traverse the entire linked list in order to add the element to the end of the linked list and because we want to consider worse case scenario it will be O(n) times.
T getMax()                  O(n)                           O(n)		   For arrayList it has to be O(n) due in fact that we have to compare everything in the current list to determine the max element in the array, and in order to that we have to consider the worst case scenario where the element is the last part of the array which would cause O(n). On the other hand for linked list we have determined that it is also O(n) because the worse case scenario would cause us to search through the entire linked list and comparing each value to each other causing the O(n).
removeDuplicates()          O(n^3)                         O(n^3)	  For arrayList is was O(n^3) because that we have to iterate through not only the current indexes but the indexes of i+1 which gives us the ability to compare the two numbers at every index, with that being said this would cause us to check every possible index and the index after and comparing them. After comparing the two indexes of the current and past values we then have the worst case scenario of having to call the remove method to remove the duplicate element and since that method utilities indexing of a while loop through the whole array it would cause in the worst case scenario a O(n^3) complexity.
 For LinkedList it is O(n^3) because the outer loop goes through the entire linked list through the nodes and the inner loop traverses the entire list once as well which would cause us to compare every single element and compare at every step causing n*n elements. After doing this we would then have the case of when they are
being compared they need to remove a duplicate in the list, which means that we would then need to call remove from our linked list which utilizes a while loop that goes through the entire linked list making it n*n*n or O(n^3).

reverse()                   O(n)                           O(n)		 For arrayList is was O(n) because we go up to the n elements in the array but even though we only go up to n/2 it still needs to be considered that we still are going through n times no matter what. As n times represents the amount of times we need to still get through the list. LinkedList is much like arrayList we want to traverse the array with n elements as we need to traverse the entire linked list in search to reverse the order. Therefore, linked list is also O(n)